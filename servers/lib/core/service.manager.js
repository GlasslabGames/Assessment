/**
 * Manager for Services
 *
 * Module dependencies:
 *  lodash     - https://github.com/lodash/lodash
 *  when       - https://github.com/cujojs/when
 *  express    - https://github.com/visionmedia/express
 *  multiparty - https://github.com/superjoe30/node-multiparty
 *
 */

var fs         = require('fs');
var http       = require('http');
var path       = require('path');
// Third-party libs
var _          = require('lodash');
var when       = require('when');
var express    = require('express');
var couchbase  = require('couchbase');

// load at runtime
var Util;

module.exports = ServiceManager;

process.on('uncaughtException', function(err) {
    console.error("ServiceManager: Uncaught Error -", err, ", stack:", err.stack);
});

function ServiceManager(configFiles){
    // called as:   new ServiceManager("~/hydra.assessment.config.json");
    // this == {}

    Util              = require('../core/util.js');
    var ConfigManager = require('../core/config.manager.js');

    var startScript = process.argv[1].split("servers/")[1];

    console.log(" **************************************** ");
    console.log("        " + startScript);
    console.log(" **************************************** ");

    console.log("ServiceManager()");

    console.log('    process.pid:         ' + process.pid);
    console.log('    process.platform:    ' + process.platform);
    console.log('    process.version:     ' + process.version);
    console.log('    process.execPath:    ' + process.execPath);
    console.log('    process.argv[1]:     ' + process.argv[1]);

    console.log('    process.env.SHLVL:   ' + process.env.SHLVL);
    console.log('    process.env.LOGNAME: ' + process.env.LOGNAME);
    console.log('    process.env.HOME:    ' + process.env.HOME);
    console.log('    process.env.PWD:     ' + process.env.PWD);
    console.log('    process.env._:       ' + process.env._);

    console.log(Util.DateGMTString()+' **** Loading Configuration...');

    var config        = new ConfigManager();
    // load config files from first to last until successful
    // if not set, then make array
    if(!configFiles) {
        configFiles = [];
    }

    // if string then make array
    if(_.isString(configFiles)) {
        configFiles = [configFiles];
    }

    // Add the base config (./config.json from Platform/servers/) at the front of the list.
    // Values in ./config.json will be replaced by newer values in eg. ~/hydra.config.json.
    // [ './config.json', '~/hydra.config.json' ]
    configFiles.unshift("./config.json");
    this.options = config.loadSync(configFiles);

    console.log('Configs loaded');
    console.log('    env: ' + this.options.env);
    console.log('    services.port: ' + this.options.services.port);
    console.log('    services.portSSL: ' + this.options.services.portSSL);
    console.log('    services.portNonSSL: ' + this.options.services.portNonSSL);
    console.log('    services.appExternalPort: ' + this.options.services.appExternalPort);
    console.log('    services.appInternalPort: ' + this.options.services.appInternalPort);
    console.log('    services.appAssessmentPort: ' + this.options.services.appAssessmentPort);
    console.log('    services.appArchiverPort: ' + this.options.services.appArchiverPort);

    if(!this.options.services) {
        this.options.services = {};
    }
    if(!this.options.services.session) {
        this.options.services.session = {};
    }

/*
    this.options.services.startScript = startScript;

    global.ENV            = this.options.env || 'dev';
    process.env.HYDRA_ENV = process.env.HYDRA_ENV || global.ENV;
    
    this.stats            = new Util.Stats(this.options, "ServiceManager");
    this.awss3            = new Util.S3Util(this.options);
    this.stripe           = new Util.StripeUtil(this.options);
*/

    global.ENV            = this.options.env || 'dev';
    process.env.HYDRA_ENV = global.ENV;
    this.stats            = new Util.Stats(this.options, "ServiceManager");

    try{
        this.routesMap = require('../routes.map.js');
    } catch(err){
        console.log("ServiceManager: Could not find default routes map.");
    }

    this.services  = {};
    this.routeList = {};
}

ServiceManager.prototype.setRouteMap = function(str) {
    this.routesMap = require(str);
};

ServiceManager.prototype.setName = function(name) {
    this.options.services.name = name;
};

ServiceManager.prototype.setPort = function(port) {
    this.options.services.port = port;
};

ServiceManager.prototype.initExpress = function() {
// add promise wrapper
return when.promise(function(resolve, reject) {
// ------------------------------------------------

    var connectPromise;
    if(this.options.services.session.store) {
        var CouchbaseStore = require('./sessionstore.couchbase.js')(express);
        this.exsStore      = new CouchbaseStore(this.options.services.session.store);
        connectPromise = this.exsStore.glsConnect();
    } else {
        var MemoryStore = express.session.MemoryStore;
        this.exsStore   = new MemoryStore();
        connectPromise = Util.PromiseContinue();
    }

    console.log('SessionStore Connecting...');
    connectPromise
        .then(function(){
            console.log('SessionStore Connected');

            this.app = express();
            this.app.set('port', process.env.PORT || this.options.services.port);

            this.app.configure(function() {

                this.app.use(Util.GetExpressLogger(this.options, express, this.stats));
                this.app.use(express.compress()); // gzip compress, Need to disable for loadtest
                this.app.use(express.errorHandler({showStack: true, dumpExceptions: true}));

                this.app.use(express.cookieParser());
                this.app.use(express.urlencoded());
                this.app.use(express.json());
                this.app.use(express.methodOverride());

                this.app.use(express.session({
                    secret: this.options.services.session.secret || "keyboard kitty",
                    cookie: _.merge({
                        path: '/'
                        , httpOnly : false
                        //, maxAge: 1000 * 60 * 24 // 24 hours
                    }, this.options.services.session.cookie),
                    store:  this.exsStore
                }));

                resolve();
            }.bind(this))
        }.bind(this))
        // catch all errors
        .then(null, reject);
// ------------------------------------------------
}.bind(this));
// end promise wrapper
};

ServiceManager.prototype.add = function(lib) {
    if(lib.ServiceName) {
        if( !this.services.hasOwnProperty(lib.ServiceName) ) {

            this.services[lib.ServiceName] = {
                lib: lib
            };
        } else {
            console.warn("ServiceManager: Service", lib.ServiceName, "Already added");
        }
    }
};

ServiceManager.prototype.get = function(name) {
    if( this.services.hasOwnProperty(name) ) {
        return this.services[name];
    } else {
        return undefined;
    }
};

ServiceManager.prototype.setupRoutes = function() {

    // api routes from map
    this.setupApiRoutes();

    // static routes from map
    this.setupStaticRoutes();

    // webapp routes
    this.setupWebAppRoutes();

    // final default routes
    this.setupDefaultRoutes();
};

ServiceManager.prototype.setupWebAppRoutes = function() {
    if( this.options &&
        this.options.webapp &&
        this.options.webapp.staticContentPath ) {
        var fullPath = path.resolve(this.options.webapp.staticContentPath);

        console.log("Static Dir Content -", fullPath);
        this.app.use( express.static(fullPath) );
    }
};

ServiceManager.prototype.setupDefaultRoutes = function() {

    // root
    this.app.get("/", function(req, res){
        //console.log("static root:", req.originalUrl);
        this.stats.increment("info", "Route.Static.Root");

        var fullPath = path.resolve(this.options.webapp.staticContentPath + "/" + this.routesMap.index);
        res.sendfile( fullPath );
    }.bind(this));

    // all others -> DEFAULT
    this.app.use(function defaultRoute(req, res) {
        this.stats.increment("info", "Route.Default");

        // server up index
        //console.log("defaultRoute:", req.originalUrl);
        //res.redirect("/");
        var fullPath = path.resolve(this.options.webapp.staticContentPath + "/" + this.routesMap.index);
        res.sendfile( fullPath );
    }.bind(this));
}


ServiceManager.prototype.setupStaticRoutes = function() {
    // add static routes
    _.forEach(this.routesMap.statics, function(s){

        _.forEach(s.routes, function(route) {
            var file = "";

            if(s.file == 'index') {
                file = this.routesMap.index;
            } else {
                file = s.file;
            }
            var fullPath = path.resolve(this.options.webapp.staticContentPath + "/" + file);

            if(s.requireAuth) {
                console.log("Auth Static Route -", route, "->", file);

                this.app.get(route, function(req, res, next) {
                    this.stats.increment("info", "Route.AuthCheck");

                    // auth
                    if( req.isAuthenticated() ) {
                        this.stats.increment("info", "Route.Auth.Ok");
                        res.sendfile( fullPath );
                    } else {
                        //
                        this.stats.increment("error", "Route.Auth.Fail");
                        // error in auth, redirect back to login
                        //console.log("headers:", req.headers);
                        console.error("Not Authenticated");

                        res.clearCookie('connect.sid', { path: '/' });
                        res.redirect("/login");
                    }
                }.bind(this));

            } else {
                console.log("Static Route -", route, "->", file);

                this.app.get(route, function(req, res) {
                    res.sendfile( fullPath );
                }.bind(this));
            }
        }.bind(this));

    }.bind(this));
};


ServiceManager.prototype.setupApiRoutes = function() {
    // add apis routes
    _.forEach(this.routesMap.apis, function(a) {
        // does not include the min required
        if(!(a.api && a.service && a.controller && a.method)) { return; }

        // ignore services that are not added
        if( this.services.hasOwnProperty(a.service) ) {
            var service        = this.services[a.service].service;
            var ControllerList = this.services[a.service].lib.Controller;
            var controller     = {};

            if( ControllerList &&
                ControllerList.hasOwnProperty(a.controller) ) {
                controller = ControllerList[a.controller];
            }

            // save route in list for route lookup
            this.routeList[ a.api ] = {};

            // add each method
            _.forEach(a.method, function(funcName, m) {
                var func = function(){};

                if( controller &&
                    controller[ funcName ] ) {
                    func = controller[ funcName ];

                    // save route with method
                    this.routeList[ a.api ][m] = {
                        service: service,
                        func:    func
                    };

                    if(a.basicAuth) {
                        console.log("Basic Auth API Route -", a.api, "-> ctrl:", a.controller, ", method:", m, ", func:", funcName);

                        // add wrapper function to check auth
                        this.app[ m ](a.api, express.basicAuth(
                                function(user, pass){
                                    return ( user == a.basicAuth.user &&
                                             pass == a.basicAuth.pass
                                    );
                                }
                            )
                        );
                    }

                    // if require auth
                    if(a.requireAuth) {
                        console.log("Auth API Route -", a.api, "-> ctrl:", a.controller, ", method:", m, ", func:", funcName);

                        // add wrapper function to check auth
                        this.app[ m ](a.api, function(req, res, next) {
                            this.stats.increment("info", "Route.AuthCheck");

                            // auth
                            if( req.isAuthenticated() ) {
                                this.stats.increment("info", "Route.Auth.Ok");
                                func.call(service, req, res, next, this);
                            } else {
                                //
                                this.stats.increment("error", "Route.Auth.Fail");
                                // error in auth, redirect back to login
                                //console.log("headers:", req.headers);
                                //console.error("Not Authenticated");

                                // if an api then return 401
                                if(req.originalUrl.indexOf("/api") != -1) {
                                    res.status(401).end();
                                } else {
                                    res.clearCookie('connect.sid', { path: '/' });
                                    res.redirect("/login");
                                }
                            }
                        }.bind(this));
                    } else {
                        console.log("API Route -", a.api, "-> ctrl:", a.controller, ", method:", m, ", func:", funcName);

                        // no login required
                        this.app[ m ](a.api, function(req, res, next) {
                            //this.stats.increment("info", "Route.Auth");
                            func.call(service, req, res, next, this);
                        }.bind(this));
                    }
                } else {
                    console.warn("Function \""+funcName+"\" not found in controller \""+a.controller+"\".");
                }
            }.bind(this));
        } else {
            console.warn("Service \""+a.service+"\" not found in services.");
        }
    }.bind(this));
};

ServiceManager.prototype.initServices = function() {
// add promise wrapper
return when.promise(function(resolve, reject) {
// ------------------------------------------------

    for(var s in this.services) {
        var service = new this.services[s].lib.Service(this.options);
        // save service
        this.services[s].service = service;

        // run app config if one exists
        if(service.appConfig) {
            service.appConfig(this.app);
        }
    }

    resolve();

// ------------------------------------------------
}.bind(this));
// end promise wrapper
};

ServiceManager.prototype.start = function(port) {
    console.log(Util.DateGMTString()+' ServiceManager start('+port+')');

    var portArg = port;

    if(!this.options.services.name){
        console.log('');
        console.log('****************    Error -- expect serverices.name set in e.g. app-app-assessment.js');
        console.log('****************             call manager.setName() in ' + this.options.services.startScript);
        console.log('');
        return;
    }

    // start express (session store,...), then start services
    this.initExpress()
        .then(function(){
            console.log('Initializing Services...');
            return this.initServices();
        }.bind(this))
        .then(function() {

            console.log('Starting Services...');
            console.log('----------------------------');
            // start all services
            var promiseList = [];
            for(var s in this.services) {
                if( this.services[s].service &&
                    this.services[s].service.start) {
                    promiseList.push( this.services[s].service.start(this) );
                }
            }

            // wait until all services are ready
            when.all(promiseList)
                .then(function(){
                    console.log('----------------------------');
                    console.log(Util.DateGMTString()+' **** Services Started');
                    console.log("Setting Up Routes...");
                    console.log('----------------------------');

                    // setup routes
                    this.setupRoutes();
                    console.log('----------------------------');
                    console.log('Routes Setup')

                    var serverPort = port || this.app.get('port');

                    console.log('Starting Server on port', serverPort, "...");

                    // start server
                    http.createServer(this.app).listen(serverPort, function createServer(){
                        console.log('Server listening on port ' + serverPort);
                        console.log('---------------------------------------------');
                        this.stats.increment("info", "ServerStarted");
                    }.bind(this));
                }.bind(this))

                .then(null, function(err){
                    console.error("ServiceManager: Service Error -", err);
                }.bind(this));

        }.bind(this))
        // catch all
        .then(null, function(err){
            console.error("ServiceManager: Start Error -", err);
        }.bind(this));
};

ServiceManager.prototype.updateUserDataInSession = function(session){
// add promise wrapper
    return when.promise(function(resolve, reject) {
// ------------------------------------------------
        var data = _.cloneDeep(session);
        delete data.id;
        delete data.req;

        var key = this.exsStore.getSessionPrefix()+":"+data.passport.user.sessionId;
        this.exsStore.set(key, data, function(err) {
            if(err) {
                this.stats.increment("error", "UpdateUserDataInSession");
                reject({"error": "failure", "exception": err}, 500);
                return;
            }
            resolve();
        }.bind(this));
// ------------------------------------------------
    }.bind(this));
// end promise wrapper
};

ServiceManager.prototype.internalRoute = function(routePath, method, args){
    if( this.routeList.hasOwnProperty(routePath) &&
        this.routeList[routePath].hasOwnProperty(method)
      ) {

        var route = this.routeList[routePath][method];

        if(_.isArray(args)) {
            args.push(this);
        } else {
            args = [args, this];
        }

        route.func.apply(route.service, args);
    }
};
